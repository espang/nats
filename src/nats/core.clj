(ns nats.core
  (:require [aleph.tcp :as tcp]
            [clojure.core.async :as async]
            [manifold.stream :as s]
            
            [nats.reader :as reader]))

(defn ^:private pong [client]
   @(s/put! @client "PONG\r\n"))

(defn ^:private info-handler [pub]
  (let [c (async/chan)
        s (async/sub pub :info c)]
    (async/go-loop []
      (let [{:keys [content]} (async/<! c)]
        (println "info:" content)
        (recur)))))

(defn ^:private ping-handler [command pub]
  (let [c (async/chan)
        s (async/sub pub :ping c)]
    (async/go-loop []
      (let [{:keys [content]} (async/<! c)]
        (println "ping")
        (async/>! command {:command :pong})
        (recur)))))

(defn ^:private pong-handler [pub]
  (let [c (async/chan)
        s (async/sub pub :pong c)]
    (async/go-loop []
      (let [{:keys [content]} (async/<! c)]
        (println "pong")
        (recur)))))

(defn connect-to-nats [host port]
  (let [messages (async/chan)
        commands (async/chan)
        r        (reader/make-reader messages)
        p        (reader/get-pub r)
        ih       (info-handler p)
        pih      (ping-handler commands p)
        poh      (pong-handler p)

        client (tcp/client {:host "localhost"
                            :port 4222})]
    (async/go-loop []
      (async/>! messages @(s/take! @client))
      (recur))
    (async/go-loop []
      (let [{:keys [command content]} (async/<! commands)]
        (case command
          :pong (pong client)
          (println "unsupported command" command))
        (recur)))
    {:client   client
     :commands commands}))

(comment
  (def client
    (connect-to-nats "localhost" 4222))
  (ping client)

  (pong (:client client)))


(comment
  (defn ping [client]
    @(s/put! @client "PING\r\n"))

  (defn connect [client connect-msg]
    @(s/put! @client (str "CONNECT " connect-msg "\r\n")))

  (defn pub
    ([client subject payload]
     @(s/put! @client (str "PUB "
                           subject
                           " "
                           (count payload)
                           "\r\n"
                           payload
                           "\r\n")))
    ([client subject reply-to payload]
     @(s/put! @client (str "PUB "
                           subject
                           " "
                           reply-to
                           " "
                           (count payload)
                           "\r\n"
                           payload
                           "\r\n"))))

                                        ; sid - connection-unique sub id generated by the client
  (defn sub
    ([client subject sid]
     @(s/put! @client (str "SUB "
                           subject
                           " "
                           sid
                           "\rn")))
    ([client subject group sid]
     @(s/put! @client (str "SUB "
                           subject
                           " "
                           group
                           " "
                           sid
                           "\rn"))))

  (defn unsub
    ([client sid]
     @(s/put! @client (str "UNSUB " sid "\r\n")))
    ([client sid max-msgs]
     @(s/put! @client (str "UNSUB " sid " " max-msgs "\r\n")))))
